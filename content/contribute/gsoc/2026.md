---
title: "Google Summer of Code 2026"
weight: 100
# summary: "Google Summer of Code 2026"
---

The Leela Chess Zero project is quite diverse and has several areas to
contribute to. Below is a list of potential projects for Google Summer of Code
2026, of varying scope and concreteness.

## Develop Python bindings for the Lc0 backends and the search

* **Skills needed:** Python, C++
* **Difficulty:** Easy / 90 hours

The current Python bindings for Lc0 are quite rudimentary and outdated. In order
to make it easier for researchers and enthusiasts to experiment with Lc0, we
need to develop comprehensive Python bindings (using pybind11 or nanobind) for
the Lc0 backends and potentially search. It should be integrated with
`python-chess`.

## Reimplementation of `live.lczero.org`

* **Skills needed:** (vanilla) TypeScript, Python
* **Difficulty:** Medium / 175 hours

`live.lczero.org` is a [web site](https://lczero.org/blog/2024/11/wcc24-live/)
where the Leela Chess Zero team run the live annotation of important chess
events (e.g., World Chess Championship). The current version was implemented in
hurry in a few days. We'd like to have a more robust and feature-rich
reimplementation, which we target to use in WCC 2026.

Some of ideas that we had in mind (for example, showing move tendencies which
are to be extracted deep from the search tree) require also Lc0 engine changes
(C++) â€” in that case, difficulty is certainly Hard and duration is longer.

It's also possible to only implement the C++ part of the project.

## Update the Metal/CoreML backends

* **Skills needed:** C++, ObjectiveC++, Metal or CoreML
* **Difficulty:** Medium / 175 hours

The lc0 backends for Apple devices have not received the same level of attention
(pun intended) as other backends. Curently we have the metal backend using Metal
Performance Shaders and (real soon now) the onnx-coreml backend using the CoreML
onnxruntime execution provided. There are several potential improvements we have
identified, with potentially more available to someone with deeper undertanding
of the aforementioned technologies:

1. Evaluate and improve suggested Metal improvements:
   * Fp16 support. [PR2132](https://github.com/LeelaChessZero/lc0/pull/2132)
   * Compile the execution graph to speed up subsequent evaluations.
   [PR2245](https://github.com/LeelaChessZero/lc0/pull/2245)
   * Use constant tensors.
   [PR2320](https://github.com/LeelaChessZero/lc0/pull/2320)
2. Check whether any of the techniques used in
   [Metal FlashAttention](https://github.com/philipturner/metal-flash-attention)
   are applicable to our nets.
3. Improve onnxruntime coreml support for variable batch size, most notably the
   [Resize](https://github.com/microsoft/onnxruntime/issues/26328) operator.
4. Add [Attention](https://onnx.ai/onnx/operators/onnx__Attention.html) in
   onnxruntime for CoreML using the
   [scaled_dot_product_attention](https://apple.github.io/coremltools/source/coremltools.converters.mil.mil.ops.defs.html#coremltools.converters.mil.mil.ops.defs.iOS18.transformers.scaled_dot_product_attention)
   operator.

## Have a JavaScript/WebAssembly backend for Lc0

* **Skills needed:** C++, JavaScript, WebAssembly
* **Difficulty:** Medium / 175 hours

Having the ability to run Lc0 directly in the browser would allow many use
cases, potentially including integrating Lc0 into lichess.  
We had several almost working prototypes of WebAssembly backends for Lc0, but
none of them was ever productionazed.

The latest attempt is [PR2072](https://github.com/LeelaChessZero/lc0/pull/2072).

We used to host [play.lczero.org](https://play.lczero.org) where everyone could
quickly play Lc0 online, which would be nice to revive. The source code for the
old version (that used lc0 running on the server) is
[here](https://github.com/Uriopass/LCPlay).

## Develop and train a CPU-focused backend for Lc0

* **Skills needed:** C++, basic machine learning knowledge
* **Difficulty:** Medium / 175 hours

To optimize the scalability of the search algorithm, we need a fast neural
network evaluation. Normally, to saturate the search, we need several high end
GPUs. However, if we had a very fast "mock" backend that would run on CPUs, we
could optimize the search on more modest hardware.

We have a few such "mock"
backends ("random" and "trivial"), but they produce unrealistic evaluation and
search results in non-representative tree shapes.

The idea is to implement a CPU-focused backend that would be fast and have
reasonable strength.

Techniques that can be used include int8 quantization and sparse matrix
multiplication or some of the methods described in
[this paper](https://arxiv.org/abs/2106.10860).

## "Remote" backend

* **Skills needed:** C++, Network programming
* **Difficulty:** Hard / 175 hours

Allow Lc0 to handle computation over the network. That allows to run local Lc0
engine while using remote hardware (e.g., GPUs in the cloud) for neural network
evaluation, or to share evaluation between multiple Lc0 games.

## Port existing backends to the new backend API

* **Skills needed:** C++
* **Difficulty:** Easy / 90 hours

Starting with Lc0 v0.32, we have a new backend API that is more flexible.
However, most of the existing backends (CUDA, OpenCL, XLA) still use the old API
through a compatibility wrapper. We need to port them to the new API to be able
to use new features and optimizations.

## Extend UCI protocol with JSON-based input and output information

* **Skills needed:** C++
* **Difficulty:** Easy / 175 hours

The UCI protocol is the standard way for chess engines to communicate with user
interfaces. However, it has limitations in terms of the amount and structure of
information that can be exchanged. We want to extend the UCI protocol to support
JSON-based messages for detailed state information, which can be useful for
analysis and debugging.

We won't use existing json libraries; instead we'll implement a JSON
serializer/deserializer in our custom protobuf code.

## Update the XLA backend to use StableHLO, through writing MLIR bytecode

* **Skills needed:** C++, MLIR, XLA
* **Difficulty:** Hard / 175 hours

The XLA backend for Lc0 currently uses an older HLO graph format. We want to
update it to use StableHLO, a MLIR-based intermediate representation for machine
learning models. We don't want to add a full MLIR dependency to Lc0, so the task
includes writing a custom MLIR bytecode writer for our neural network format,
and update the XLA backend to write StableHLO.

Having MLIR bytecode writer will also open possibilities for future backends and
ways to write kernels, like Triton or cuTile.

## Support for foreign neural network formats (e.g., Ceres)

* **Skills needed:** C++, ONNX
* **Difficulty:** Medium / 175 hours

Lc0 currently uses its own neural network format, and supports generic ONNX as
well. There are other engines which use different formats, like Ceres, Stockfish
NNUE, or Monty. Supporting these formats would allow more experiments, and with
faster nets (e.g., Stockfish NNUE) we may have a faster backend for search
optimization.

## Update of the selfplay training client and server

This is a part of `dev.lczero.org`, see below.

* **Skills needed:** Golang, PostgreSQL
* **Difficulty:** Medium / 175 hours

The current selfplay training client and server are quite old and lack important
features. We want to update them to support new features like:

* Action replay training (where the played games replay previously played
  moves).
* More stable opening book for matches (server would coordinate which opening
  every individual client should use). That would allow to have less noisy Elo
  measurements.

## Tools for analyzing Lc0 neural networks

* **Skills needed:** Python, Colab, Neural network knowledge
* **Difficulty:** Medium / 175 hours

We want to develop a set of tools (e.g., Jupyter notebooks or Google Colab
scripts) to analyze and visualize the activations and weights of Lc0 neural
networks. This would help researchers and enthusiasts to understand how Lc0
works internally, and potentially lead to new insights and improvements.

## Less concrete projects

There are some areas where there are always tasks to be done, but they are less
concrete and more handwavy, often depending on the current needs of the project.
Participants interested in these areas should be ready to discuss with the
mentors to define a more specific project scope. Examples include:

### JAX training pipeline improvements

* **Skills needed:** Python, JAX
* You would also need to have a modern GPU available.

We have recently switched our training pipeline to use JAX. Current potential
tasks include supporting to settings change without restarting the training,
adding layer freezing, adding more model types, and improving the TUI.

### Model architecture experiments

* **Skills needed:** Python, JAX, Model design
* You would also need to have a modern GPU available.

We are continuously experimenting with new neural network architectures for Lc0.
If you have ideas for new architectures, you can implement them and run training
experiments.

Ideas that have been discussed but not yet fully evaluated include additional
input planes giving the net extra information for the position and int8/fp8
quantization.

### Search improvements and lc3 tasks

* **Skills needed:** C++

We are in the process of developing `lc3`, a new implementation of the search
algorithm. Once it's in a more mature state, there will be many tasks related to
optimizing it and adding features (e.g. external node storage).

### dev.lczero.org

* **Skills needed:** Python/Django, potentially Golang and TypeScript

`dev.lczero.org` is our internal development portal which is being developed.
The large part of it will be a selfplay coordination system, but there many
other small feature are planned:

* Monitoring and alerting system.
* URL shortener administration.
* Network file storage and management.
* Competition participation tracking.
* Benchmarking and tuning infrastructure
* Etc.
